\section{{\tt parse.par}: Select and reshape parameter vectors}\label{parse.par}

\subsubsection{Description}

The {\tt parse.par()} function reshapes parameter vectors for
compatability with the output matrix from {\tt
model.matrix.multiple()}. (See\Sref{model.matrix.multiple}.)  Use {\tt
parse.par()} to identify sets of parameters; for example, within
optimization functions that require vector input, or within {\tt qi()}
functions that take matrix input of all parameters as a lump.  

\subsubsection{Syntax}
\begin{verbatim}
parse.par(par, terms, shape = "matrix", eqn = NULL)
\end{verbatim}

\subsubsection{Arguments}

\begin{itemize}
\item {\tt par}: the vector (or matrix) of parameters.
\item {\tt terms}: the terms from either {\tt model.frame.*()} or 
		{\tt model.matrix.*()}.
\item {\tt shape}: a character string (either {\tt "matrix"} or {\tt "vector"})
that identifies the type of output structure. 
\item {\tt eqn}: a character string (or strings) that identify the
parameters that you would like to subset from the larger {\tt par}
structure.
\end{itemize}

\subsubsection{Output Values}
A matrix or vector of the sub-setted (and reshaped) parameters for the specified
parameters given in {\tt eqn}.   By default, {\tt eqn = NULL}, such that all systematic
components are selected.  (Systematic components have {\tt ExpVar =
TRUE} in the appropriate {\tt describe.model()} function.)  

If an ancillary parameter (for which {\tt ExpVar = FALSE} in
{\tt describe.model()}) is specified in {\tt eqn}, it is
always returned as a vector (ignoring {\tt shape}).  (Ancillary
parameters are all parameters that have intercept only formulas.)  

\subsubsection{Examples}
Let's say that the name of the model is {\tt "bivariate.probit"}, and
the corresponding describe function is {\tt
describe.bivariate.probit()}, which identifies {\tt mu1} and {\tt mu2}
as systematic components, and an ancillary parameter {\tt rho}, which
may be parameterized, but is estimated as a scalar by default.  Let
{\tt par} be the parameter vector (including parameters for {\tt
rho}), {\tt formulae} a user-specified formula given in one of the
formats in Table \ref{good.formulas}, and {\tt mydata} the user
specified data frame.  

Acceptable combinations of {\tt parse.par()} and {\tt model.matrix()}
are as follows:
\begin{verbatim}
## Setting up
fml <- parse.formula(formulae, model = "bivariate.probit")
D <- model.frame(fml, data = mydata)
terms <- terms(D)

## Intuitive option
Beta <- parse.par(par, terms, shape = "vector", eqn = c("mu1", "mu2"))
X <- model.matrix(fml, data = D, shape = "stacked", eqn = c("mu1", "mu2")
eta <- X %*% Beta

## Memory-efficient (compact) option (default)
Beta <- parse.par(par, terms, eqn = c("mu1", "mu2"))    
X <- model.matrix(fml, data = D, eqn = c("mu1", "mu2"))
eta <- X %*% Beta

## Computationally-efficient (array) option
Beta <- parse.par(par, terms, shape = "vector", eqn = c("mu1", "mu2"))
X <- model.matrix(fml, data = D, shape = "array", eqn = c("mu1", "mu2"))
eta <- apply(X, 3, '%*%', Beta)
\end{verbatim}
In each case, {\tt eta} is an $n \times 2$ matrix with columns
corresponding to the linear predictors for {\tt mu1} and {\tt mu2},
respectively.  

\subsubsection{See Also}
\begin{itemize}
\item \Sref{model.matrix.multiple} for a description of how multiple
equation models work with {\tt model.matrix()}.  
\item \Sref{constraints} for more detail on the three combinations
(intuitive, memory-efficient, and computationally-efficient) methods
of multiplying matrices of parameters and variables.  
\end{itemize}

\subsubsection{Contributors}

Kosuke Imai, Gary King, Olivia Lau, and Ferdinand Alimadhi.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "~/zelig/docs/zelig"
%%% End: 
