\section{{\tt model.matrix.multiple}: Design matrix for multivariate models}
\label{model.matrix.multiple}

\subsubsection{Description}
Use {\tt model.matrix.multiple()} after {\tt parse.formula()} to
create a design matrix for multiple-equation models.  
  
\subsubsection{Syntax}
\begin{verbatim}
model.matrix(object, data, shape = "compact", eqn = NULL, ...)
\end{verbatim}

\subsubsection{Arguments}
\begin{itemize}
  \item {\tt object}: the list of formulas output from \texttt{parse.formula()}.
  \item {\tt data}: a data frame created with {\tt model.frame.multiple()}. 
 \item {\tt shape}: a character string specifying the shape of the
 outputed matrix.  Available options are:  

\begin{itemize} 

\item {\tt "compact"}: (default) the output matrix will be an $n \times v$,
where $v$ is the number of unique variables in all of the equations
(including the intercept term). 

\item {\tt "array"}: the output is an $n \times K \times J$ array where $J$ is the
total number of equations and $K$ is the total number of parameters
across all the equations.  If a variable is not in a certain equation,
it is observed as a vector of 0s. 

\item {\tt "stacked"}: the output will be a $2n \times K$ matrix where $K$ is the total number of parameters across all the equations.

\end{itemize}
  
  \item {\tt eqn}: a character string or a vector of character
  strings identifying the equations from which to construct the design
  matrix. The defaults to {\tt NULL}, which only uses the systematic
  parameters (for which {\tt DepVar = TRUE} in the appropriate {\tt
describe.model()}) .  
\item {\tt \dots}:  additional arguments passed to {\tt model.matrix.default()}.  
\end{itemize}

\subsubsection{Output Values}
A design matrix or array, depending on the options chosen in {\tt
shape}, with appropriate terms attributes.  

\subsubsection{Examples}
Let's say that the name of the model is {\tt "bivariate.probit"}, and
the corresponding describe function is {\tt
describe.bivariate.probit()}, which identifies {\tt mu1} and {\tt mu2}
as systematic components, and an ancillary parameter {\tt rho}, which
may be parameterized, but is estimated as a scalar by default.  Let
{\tt par} be the parameter vector (including parameters for {\tt
rho}), {\tt formulae} a user-specified formula given in one of the
formats in Table \ref{good.formulas}, and {\tt mydata} the user
specified data frame.  

Acceptable combinations of {\tt parse.par()} and {\tt model.matrix()}
are as follows:
\begin{verbatim}
## Setting up
fml <- parse.formula(formulae, model = "bivariate.probit")
D <- model.frame(fml, data = mydata)
terms <- terms(D)

## Intuitive option
Beta <- parse.par(par, terms, shape = "vector", eqn = c("mu1", "mu2"))
X <- model.matrix(fml, data = D, shape = "stacked", eqn = c("mu1", "mu2")
eta <- X %*% Beta

## Memory-efficient (compact) option (default)
Beta <- parse.par(par, terms, eqn = c("mu1", "mu2"))    
X <- model.matrix(fml, data = D, eqn = c("mu1", "mu2"))
eta <- X %*% Beta

## Computationally-efficient (array) option
Beta <- parse.par(par, terms, shape = "vector", eqn = c("mu1", "mu2"))
X <- model.matrix(fml, data = D, shape = "array", eqn = c("mu1", "mu2"))
eta <- apply(X, 3, '%*%', Beta)
\end{verbatim}
In each case, {\tt eta} is an $n \times 2$ matrix with columns
corresponding to the linear predictors for {\tt mu1} and {\tt mu2},
respectively.  

\subsubsection{See Also}
\begin{itemize}
\item \Sref{parse.par} for selecting and shaping parameter vectors.  
\item \Sref{s:new} for examples of how to write new models.  
\end{itemize}

\subsubsection{Contributors}

Kosuke Imai, Gary King, Olivia Lau, and Ferdinand Alimadhi.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 












